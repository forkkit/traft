syntax = "proto3";

option go_package = ".;traft";

//
// Unexchangeble logs: r1 and r3. They both modify the same key `x`.
// r1 and r2, r2 and r3 are exchangeable.
//
//  r3: set x = 2  <-.
//  r2: set y = 1    |
//  r1: set x = 1  <-'

// Issue about the original raft
//
// 1. Only one leader can be established in a `term`.
// Such a design introduces more conflict if multiple replicas try to become a
// leader in a short time.
//
// Solution
//
// blabla TODO 


// TODO: remove useless field in proto struct:
//
//   type LeaderId struct {
//     state         protoimpl.MessageState
//     sizeCache     protoimpl.SizeCache
//     unknownFields protoimpl.UnknownFields

// Cmd defines the action a log record does
message Cmd {
    string Op = 10;
    string Key = 20;

    oneof Value {
        string VStr = 31;
        int64 VI64 = 32;

        // cluster config change: adding/removing members.
        ClusterConfig VClusterConfig = 33;
    }
}

// TailBitmap is a bitmap that has all its leading bits set to `1`.
// Thus it is compressed with an Offset of all-ones position and a trailing
// bitmap.
// It is used to describe Record dependency etc.
// 
// The data structure is as the following described:
//
//                      reclaimed
//                      |
//                      |     Offset
//                      |     |
//                      v     v
//                ..... X ... 01010...00111  00...
//   bitIndex:    0123...     ^              ^
//                            |              |
//                            Words[0]       Words[1]
//
message TailBitmap {
    int64 Offset = 1;
    repeated uint64 Words = 2;
    int64 Reclamed = 3;
}

// Record is a log record
message Record {
    // Which leader proposed this log.
    //
    // TODO It seems this field is useless. Because we already have `Accepted`.
    // This is different from the original raft:
    // raft does not have a explicit concept `accepted`, which is enssential in
    // paxos.
    // Instead, The `commited` in raft is defined as: leader forwards its
    // own term log to a quorum.
    LeaderId By = 1;

    // Log sequence number.
    int64 Seq = 10;

    // Cmd describes what this log does.
    Cmd Cmd = 30;

    // Overrides describes what previous logs this log record overrides.
    TailBitmap Overrides = 40;
}


message ReplicateReply {
}


message LeaderId {
    int64 Term = 1;
    int64 Id = 2;
}


// The replica that has the latest log is allow to be a new leader.
// I.e., log is forwarded from latest leader(max AcceptedFrom), and has the highest
// log seq number.
// Then a leader is chosen from these candidates by their Current leader id.
// The max LeaderId wins.
message Ballot {
    LeaderId AcceptedFrom = 1;
    TailBitmap Accepted = 2;

    // TODO Progress needs a Ballot
    LeaderId Current = 3;
}


message Node {
    ClusterConfig Config = 1;
    repeated Record Log = 2;

    // last seen term
    int64 Term = 3;

    int64 Id = 10;

    // which replica it has voted for as a leader.
    //
    // Accepted is the same as VotedFor after receiving one log-replication
    // message from the leader.
    //
    // Before receiving a message, VotedFor is the leader this replica knows of,
    // Accepted is nil.
    LeaderId VotedFor = 5;

    // local view of other replicas
    map<int64, ReplicaProgress> Progresses = 6;
}

message ReplicaProgress {
    // similar to the vrnd/vballot concept in paxos.
    // the Ballot number a value is accepted at.
    //
    LeaderId AcceptedFrom = 4;

    // What logs has been accepted by this replica.
    TailBitmap Accepted = 1;
    TailBitmap Committed = 2;
    TailBitmap Applied = 3;
}

message ReplicaInfo {
    int64 Id = 1;
    string Addr = 2;
}

message ClusterConfig {
    repeated ReplicaInfo Members = 11;
    repeated uint64 Quorums = 21;
}

message VoteReq {
    Ballot Bal = 1;
    // Has: what logs the sender has.
    TailBitmap Accepted = 2;
}

message VoteReply {
    // voter's term.
    // If voter's term is greater, sender should upgrade its own term and retry.

    // On which accepted term voter's log are written.
    // If voter accepted term >= sender's accepted term,
    // voter send back the logs that only voter has.
    // Otherwise, voter's log can not be committed, no need to send.
    //
    // If a voter seen a bigger accepted term than its own.
    // that means its logs are not committed.

    Ballot Bal = 1;

    repeated Record Logs = 30;
}

service TRaft {
    rpc Vote (VoteReq) returns (VoteReply) {}
    rpc Replicate (Record) returns (ReplicateReply) {}
}
